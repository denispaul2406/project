{"print()": "prints the syntax",
"pow()": "adds power to an integer",
"int()": "converts a character to integer",
"float()": "converts a character to float",
"str()": "converts a character to string",
"abs()": "returns the absolute value of a character",
"complex(re,im)": "a complex number with real part re, imaginary part im. im defaults to zero.",
"+": "sum, addition",
"-": "difference, subtraction",
"*": "product, multiplication",
"/": "quotient",
"//": "floored quotient",
"%":"remainder",
"** ": "power",
"c.conjugate()": "conjugate of the complex number c",
"divmod(x, y)": "the pair (x // y, x % y)",
"<": "strictly less than",
"<=": "less than or equal",
">": "strictly greater than",
">=": "greater than or equal",
"==": "equal",
"!": "not equal",
"is not": "negated object identity",
"math.trunc(x)": "x truncated to Integral",
"round(x[, n])": "x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0.",
"math.floor(x)": "the greatest Integral <= x",
"math.ceil(x)": "the least Integral >= x",
"x | y": "bitwise or of x and y",
"x ^ y": "bitwise exclusive or of x and y",
"x & y": "bitwise and of x and y",
"x << n": "x shifted left by n bits",
"x >> n": "x shifted right by n bits",
"~x": "the bits of x inverted",
"x in s": "True if an item of s is equal to x, else False",
"x not in s": "False if an item of s is equal to x, else True",
"s+t": "the concatenation of s and t",
"s * n or n * s": "equivalent to adding s to itself n times",
"s[i]": "ith item of s, origin 0",
"s[i:j]": "slice of s from i to j",
"s[i:j:k]": "slice of s from i to j with step k",
"len(s)": "length of s",
"min(s)": "smallest item of s",
"max(s)": "largest item of s",
"s.index(x[, i[, j]])": "index of the first occurrence of x in s (at or after index i and before index j)",
"s.count(x)": "total number of occurrences of x in s",
"[]": "Using a pair of square brackets to denote the empty list",
"[a], [a, b, c]": "Using square brackets, separating items with commas",
"[x for x in iterable]": "Using a list comprehension",
"list() or list(iterable)": "Using the type constructor",
"()": "Using a pair of parentheses to denote the empty tuple",
"a, or (a,)": "Using a trailing comma for a singleton tuple",
"a, b, c or (a, b, c)": "a, b, c or (a, b, c)",
"tuple() or tuple(iterable)": "Using the tuple() built-in",
"str.capitalize()": "Return a copy of the string with its first character capitalized and the rest lowercased.",
"str.casefold()": "Return a casefolded copy of the string. Casefolded strings may be used for caseless matching.",
"str.center(width[, fillchar])": "Return centered in a string of length width. Padding is done using the specified fillchar (default is an ASCII space). The original string is returned if width is less than or equal to len(s).",
"str.count(sub[, start[, end]])": "Return the number of non-overlapping occurrences of substring sub in the range [start, end]. Optional arguments start and end are interpreted as in slice notation.",
"str.encode(encoding='utf-8', errors='strict')": "Return an encoded version of the string as a bytes object. Default encoding is 'utf-8'. errors may be given to set a different error handling scheme",
"str.endswith(suffix[, start[, end]]": "Return True if the string ends with the specified suffix, otherwise return False",
"True, False":"True and False are truth values in Python. They are the results of comparison operations or logical (Boolean) operations in Python",  
"None":"None is a special constant in Python that represents the absence of a value or a null value.", 
"and":"and is a logical operator in Python. 'and' will result into True only if both the operands are True",
"or":"or is a logical operator in Python. 'or' will result into True if any of the operands is True", 
"not":"not is a the logical operator in Python. 'not' operator is used to invert the truth value", 
"as":"as is used to create an alias while importing a module. It means giving a different name (user-defined) to a module while importing it.", 
"assert":"assert is used for debugging purposes.While programming, sometimes we wish to know the internal state or check if our assumptions are true. assert helps us do this and find bugs more conveniently. assert is followed by a condition.If the condition is true, nothing happens. But if the condition is false, AssertionError is raised", 
"async":"async keyword specifies that the function will be executed asynchronously.", 
"await":"await keyword makes the program wait for 1 second", 
"break":"break will end the smallest loop it is in and control flows to the statement immediately below the loop", 
"continue":"continue causes to end the current iteration of the loop, but not the whole loop.", 
"class":"class is used to define a new user-defined class in Python. Class is a collection of related attributes and methods that try to represent a real-world situation. This idea of putting data and functions together in a class is central to the concept of object-oriented programming (OOP)",  
"def":"def is used to define a user-defined function.Function is a block of related statements, which together does some specific task. It helps us organize code into manageable chunks and also to do some repetitive task.", 
"del":"del is used to delete the reference to an object.'del' is also used to delete items from a list or a dictionary", 
"if":"if is used for conditional branching or decision making. When we want to test some condition and execute a block only if the condition is true, then we use if", 
"elif":"elif is used for conditional branching or decision making.When we want to test some condition and execute a block only if the condition is true, then we use elif", 
"else":"else is used for conditional branching or decision making.'else' is the block which is executed if the condition is false", 
"try":"try...except blocks are used to catch exceptions in Python.", 
"except":"try...except blocks are used to catch exceptions in Python.", 
"raise":"We can raise an exception explicitly with the raise keyword", 
"finally":"finally is used with try…except block to close up resources or file streams. Using finally ensures that the block of code inside it gets executed even if there is an unhandled exception", 
"for":"for is used for looping. Generally we use for when we know the number of times we want to loop.", 
"import":"import keyword is used to import modules into the current namespace", 
"from":"from…import is used to import specific attributes or functions into the current namespace", 
"global":"global is used to declare that a variable inside the function is global (outside the function).", 
"in":"in is used to test if a sequence (list, tuple, string etc.) contains a value. It returns True if the value is present, else it returns False", 
"is":"is is used in Python for testing object identity. 'is' is used to test if the two variables refer to the same object.It returns True if the objects are identical and False if not", 
"lambda":"lambda is used to create an anonymous function (function with no name). It is an inline function that does not contain a return statement. It consists of an expression that is evaluated and returned.", 
"nonlocal":"nonlocal is used to declare that a variable inside a nested function (function inside a function) is not local to it, meaning it lies in the outer inclosing function", 
"pass":"pass is a null statement in Python. Nothing happens when it is executed. It is used as a placeholder.", 
"return":"return statement is used inside a function to exit it and return a value.",
"while":"while is used for looping in Python.The statements inside a while loop continue to execute until the condition for the while loop evaluates to False or a break statement is encountered", 
"with":"with statement is used to wrap the execution of a block of code within methods defined by the context manager.ontext manager is a class that implements __enter__ and __exit__ methods. Use of with statement ensures that the __exit__ method is called at the end of the nested block",
"yeild":"yield returns a generator.Generator is an iterator that generates one item at a time. A large list of values will take up a lot of memory. Generators are useful in this situation as it generates only one value at a time instead of storing all the values in memory" 
}


    